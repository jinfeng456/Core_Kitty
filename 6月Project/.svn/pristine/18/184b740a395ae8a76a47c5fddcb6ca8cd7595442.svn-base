using System.Collections.Generic;
using GK.WCS.Crane;
using GK.WCS.Crane.dto;

namespace GK.WCS.Crane {
    public class TaskOrderUtil {
        
       public const int CENTER_DISTANCE = 6150;//货叉大概距离 用于计算行走时间，不能直接使用的定位上
        /**
         * 从多个中取两个的逻辑，仅在垛机货叉都为空闲的时候使用
         * */
        public static TaskOrder pick2(int x,int y,List<FullTask> fullTaskList) {
            int count = fullTaskList.Count;
            if(fullTaskList.Count == 1) {
                TaskOrder order1 = onlyOne( x,y,fullTaskList,1);
                TaskOrder order2 = onlyOne(x,y,fullTaskList,2);
                return MathUtil.min(order1,order2);
            } 
           TaskOrder minOrder = null;
            for(int i = 0;i < count;i++) {
                FullTask ft1 = fullTaskList[i];
                TaskOrder order = fromTask(x,y,ft1,fullTaskList);
                minOrder = MathUtil.min(minOrder,order);
            }
            return minOrder;
        }
        /**
         * 仅一个任务时
         * */
        private static TaskOrder onlyOne(int x,int y,List<FullTask> fullTaskList,int forkNO) {
            FullTask ft = fullTaskList[0];
            if(forkNO == 2) {
                x += CENTER_DISTANCE;
            }
            TaskOrder order = new TaskOrder(ft.getPickTime(x,y),ft,ft.pick,forkNO);
            TaskOrder order2 = new TaskOrder(ft.getPutTime(ft.pick.locX,ft.pick.locY),ft,ft.put,forkNO);
            order.add(order2);
            return order;
        }
        public static TaskOrder fromTask(int x,int y,FullTask ft1,List<FullTask> fullTaskList) {
            TaskOrder order1 = pick(x,y,ft1,fullTaskList,1);

            TaskOrder order2 = pick(x,y,ft1,fullTaskList,2);
            return MathUtil.min(order1,order2);
        }
        /**
         *  x 垛机上显示的x轴位置
         * 
         * */
        public static TaskOrder pick(int x,int y,FullTask ft1,List<FullTask> fullTaskList,int forkNo) {
            if(forkNo == 2) {//如果时2号货叉，取货位置应该少一个中心距，即目标位置减一个中心距， 坐标变换得当前位置增加一个中心距，即为行走距离
                x += CENTER_DISTANCE;
            }
            TaskOrder order1 = new TaskOrder(ft1.getPickTime(x,y),ft1,ft1.pick,forkNo);
            TaskOrder order1Next1 = pickFirstFinsh(ft1,forkNo,fullTaskList);
            order1.add(order1Next1);
            return order1;
        }
        static TaskOrder pickFirstFinsh(FullTask ft1,int forkno,List<FullTask> fullTaskList) {
            int x = ft1.pick.locX;
            int y = ft1.pick.locY;
            TaskOrder minOrder = null;
            foreach(FullTask ft in fullTaskList) {
                if(ft.pick.id == ft1.pick.id) {//同一个对象
                    continue;
                }
                TaskOrder pickRorder = pickTegether(ft1,forkno,ft);
                minOrder = MathUtil.min(minOrder,pickRorder);
                pickRorder = oneByOne(ft1,forkno,ft);
                minOrder = MathUtil.min(minOrder,pickRorder);
            }
            return minOrder;
        }
        private static TaskOrder pickTegether(FullTask ft1,int forkno,FullTask otherFt) {//取两个货的时间
            int x = ft1.pick.locX;
            int y = ft1.pick.locY;
            if(forkno == 1) {//第一个次取货使用
                x += CENTER_DISTANCE;
            } else if(forkno == 2) {
                x -= CENTER_DISTANCE;
            }
            TaskOrder order = new TaskOrder(otherFt.getPickTime(x,y),otherFt,otherFt.pick,3- forkno);

            x = otherFt.pick.locX;
            y = otherFt.pick.locY;
            if(forkno == 1) {//当前货叉为2
                x -= CENTER_DISTANCE;
            }

            if(forkno == 1) {
                TaskOrder childOrder = put2minTime(x,y,ft1,otherFt);
                order.add(childOrder);
            } else {
                TaskOrder childOrder = put2minTime(x,y,otherFt,ft1);
                order.add(childOrder);
            }
           
            return order;
        }
        private static TaskOrder oneByOne(FullTask ft1,int forkno,FullTask ft) {
            if(forkno == 1) {
                TaskOrder order1 = new TaskOrder(ft1.getPutTime(ft1.pick.locX,ft1.pick.locY),ft1,ft1.put,forkno);
                TaskOrder order2 = new TaskOrder(ft.getPickTime(ft1.put.locX+ CENTER_DISTANCE,ft1.put.locY),ft,ft.pick,3- forkno);
                TaskOrder order3 = new TaskOrder(ft.getPutTime(ft.pick.locX+ CENTER_DISTANCE,ft.pick.locY),ft,ft.put,3 - forkno);
                order2.add(order3);
                order1.add(order2);
                return order1;
            } else {
                TaskOrder order1 = new TaskOrder(ft1.getPutTime(ft1.pick.locX+ CENTER_DISTANCE,ft1.pick.locY),ft1,ft1.put,forkno);
                TaskOrder order2 = new TaskOrder(ft.getPickTime(ft1.put.locX,ft1.put.locY),ft,ft.pick,3 - forkno);
                TaskOrder order3 = new TaskOrder(ft.getPutTime(ft.pick.locX,ft.pick.locY),ft,ft.put,3 - forkno);
                order2.add(order3);
                order1.add(order2);
                return order1;
            }
            
        }

        public static TaskOrder put2minTime(int x,int y,FullTask ft1,FullTask ft2) {//放两个货的时间
            TaskOrder order = new TaskOrder(0,null,null,0);
            TaskOrder last = new TaskOrder(0,null,null,0);
            order.add(last);
            
            int t1 = ft1.getPutTime(x,y) + ft2.getPutTime(ft1.put.locX+ CENTER_DISTANCE,ft1.put.locY);
            int t2 = ft2.getPutTime(x+ CENTER_DISTANCE,y) + ft1.getPutTime(ft2.put.locX,ft2.put.locY);
            
            if(t1 < t2) {
                order.tc1 = ft1.put;
                order.ft = ft1;
                order.forkNo = 1;

                last.tc1 = ft2.put;
                last.ft = ft2;
                last.forkNo = 2;
                order.time = t1;
            } else {
                order.tc1 = ft2.put;
                order.ft = ft2;
                order.forkNo =2;
                last.tc1 = ft1.put;
                last.ft = ft1;
                last.forkNo = 1;
                order.time = t2;
            }
            return order;
        }

        public static TaskOrder firstUnworkTaskOrder(List<TaskOrder> list) {
            foreach(TaskOrder o in list) {
                if(CraneTools.isFinsh(o.getTask())) {
                    continue;
                }
                return o;
            }
            return null;
        }
    }
}
