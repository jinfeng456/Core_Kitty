using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using CMNetLib.Robots.Crane;
using GK.WCS.Entity;
using GK.WCS.Crane.dto;

namespace GK.WCS.Crane {
    
    public class MathUtil {
        public static FullTask getFullTask(TaskCrane tc,List<FullTask> res) {
            for(int i = 0;i < res.Count;i++) {
                FullTask ft = res[i];
                if(ft.pick.id == tc.id|| ft.put.id == tc.id) {
                   return ft;
                }
            }
            return null;
        }
        public static bool at(int X,int Y,RobotStatus status) {
            int x = decimal.ToInt32(status.NowX);
            int y = decimal.ToInt32(status.NowY) ;
            return at( X, Y, x, y);
        }

        public static bool at(int X,int Y,int x,int y) {

            int defX = x - X;
            int defY = y - Y;
            if(Math.Abs(defX) < 1000 && Math.Abs(defY) < 1000) {
                return true;
            }
            return false;
        }

        public static TaskOrder onlyOne(int x,int y,List<FullTask> fullTaskList) {
            FullTask ft = fullTaskList[0];
            TaskOrder order = new TaskOrder(ft.getPickTime(x,y),ft,ft.pick,0);
            TaskOrder order2 = new TaskOrder(0,ft,ft.put,0);
            order.add(order2);
            return order;
        }

        public static TaskOrder pick2(int x,int y,List<FullTask> fullTaskList) {
            int count = fullTaskList.Count;
            if(fullTaskList.Count == 1) {
                return onlyOne( x,y,fullTaskList);
            } 
           TaskOrder minOrder = null;
            for(int i = 0;i < count;i++) {
                FullTask ft1 = fullTaskList[i];
                TaskOrder order = fromTask(x,y,ft1,fullTaskList);
                minOrder = min(minOrder,order);
            }

            return minOrder;
        }

       public static TaskOrder fromTask(int x,int y,FullTask ft1,List<FullTask> fullTaskList) {
            TaskOrder order = new TaskOrder(ft1.getPickTime(x,y),ft1,ft1.pick,0);
        

            TaskOrder order1 = pickFirst(ft1,fullTaskList);
            order.add(order1);
            return order;

        }


        public static TaskOrder pick(int x,int y,List<FullTask> fullTaskList) {
            int count = fullTaskList.Count;
            TaskOrder minOrder = null;
            for(int i = 0;i < count;i++) {
                FullTask ft = fullTaskList[i];
                TaskOrder order2 = new TaskOrder(ft.getPickTime(x,y),ft,ft.pick,0);
                TaskOrder order3 = new TaskOrder(ft.getPutTime(ft.pick.locX,ft.pick.locY),ft,ft.put,0);
                order2.add(order3);
                minOrder = min(minOrder,order2);
            }

            return minOrder;
        }


        static TaskOrder pickFirst(FullTask ft1,List<FullTask> fullTaskList) {

            int x = ft1.pick.locX;
            int y = ft1.pick.locY;

            int count = fullTaskList.Count;
            if(fullTaskList.Count == 1) {
                return onlyOne(x,y,fullTaskList);
            }
            TaskOrder minOrder = null;

            foreach(FullTask ft in fullTaskList) {
                if(ft.pick.id == ft1.pick.id) {//同一个对象
                    continue;
                }
                TaskOrder pickRorder = pickTegether(ft1,ft);
                minOrder = min(minOrder,pickRorder);
                pickRorder = oneByOne(ft1,ft);
                minOrder = min(minOrder,pickRorder);
            }
            return minOrder;
        }
        /**
         *  //取ft1的情况下，
         * */

        private static TaskOrder pickTegether(FullTask ft1,FullTask ft) {//取两个货的时间
            int x = ft1.pick.locX;
            int y = ft1.pick.locY;
            TaskOrder order = new TaskOrder(ft.getPickTime(x,y),ft,ft.pick,0);
       
            x = ft.pick.locX;
            y = ft.pick.locY;
            TaskOrder childOrder = put2minTime(x,y,ft1,ft);

            order.add(childOrder);
            return order;
        }
        private static TaskOrder oneByOne(FullTask ft1,FullTask ft) {
            TaskOrder order1 = new TaskOrder(ft1.getPutTime(ft1.pick.locX,ft1.pick.locY),ft1,ft1.put,0);
            TaskOrder order2 = new TaskOrder(ft.getPickTime(ft1.put.locX,ft1.put.locY),ft,ft.pick,0);
            TaskOrder order3 = new TaskOrder(ft.getPutTime(ft.pick.locX,ft.pick.locY),ft,ft.put,0);
            order2.add(order3);
            order1.add(order2);
            return order1;
        }

        public static TaskOrder put2minTime(int x,int y,FullTask ft1,FullTask ft2) {//放两个货的时间

            TaskOrder order = new TaskOrder(0,null,null,0);
            TaskOrder last = new TaskOrder(0,null,null,0);
            order.add(last);
            int t1 = ft1.getPutTime(x,y)+ ft2.getPutTime(ft1.put.locX,ft1.put.locY);
            int t2 = ft2.getPutTime(x,y) + ft1.getPutTime(ft2.put.locX,ft2.put.locY);
            if(t1 < t2) {
                order.tc1 = ft1.put;
                order.ft = ft1;

                last.tc1 = ft2.put;
                last.ft = ft2;
                order.time = t1;
            } else {
                order.tc1 = ft2.put;
                order.ft = ft2;
                last.tc1 = ft1.put;
                last.ft = ft1;
                order.time = t2;
            }
             
            return order;
        }

        public static TaskOrder min(TaskOrder minOrder,TaskOrder order1) {
            if(minOrder == null) {
                return order1;
            }
            if(minOrder.time > order1.time) {
                return order1;
            }
            return minOrder;
        }

    }
}
