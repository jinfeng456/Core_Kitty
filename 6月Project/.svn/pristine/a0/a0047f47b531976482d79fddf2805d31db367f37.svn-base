
using System.Collections.Generic;

using CMNetLib.Robots.Crane;

using System;
using GK.WCS.Crane.dto;
using GK.WCS.Common;
using GK.WCS.Common.core.dto;
using GK.WCS.Carrier;
using GK.WCS.DAL;
using GK.WCS.Entity;

namespace GK.WCS.Crane {
    public abstract class CraneDoubleForkTask:CraneAllocateJobHX {

        IPhysicalLocationServer physicalLocationServer = ServerFactray.getServer<IPhysicalLocationServer>();
        INoTaskControlServer noTaskControlServer = ServerFactray.getServer<INoTaskControlServer>();
        public CraneDoubleForkTask(int id) : base(id) {
        }
       
        
        bool checkCraneDB(List<TaskStatusModel> models,TaskCrane Task1,TaskCrane Task2) {
            bool val = TaskStatusUtil.check(models[0],Task1);
            if(!val) {
                return false;
            }
            return TaskStatusUtil.check(models[1],Task2);
        }

        sealed public override TaskModel analyseTaskModel() {
            TaskModel model = getWorkModle();
            return model;
        }
        TaskModel getWorkModle() {
            List<TaskCrane> tcList = craneTaskDAL.getWorkingTask(CraneId);
            TaskCrane Task1 = TaskStatusUtil.getForkTask(tcList,1);//1号货叉正在执行或者将要执行的任务
            TaskCrane Task2 = TaskStatusUtil.getForkTask(tcList,2);//2hao 
            int t1 = TaskStatusUtil.task2Type(Task1);
            int t2 = TaskStatusUtil.task2Type(Task2);
            bool val = checkCraneDB(status.TaskState,Task1,Task2);
            if(!val) {
                LoggerCommon.fileAll("数据库与垛机任务不匹配");
                return null;
            }
            int x = decimal.ToInt32(status.NowX);
            int y = decimal.ToInt32(status.NowY);
            //1,空闲，2取货中，3取货完成，4 放货中

            int t = t1 * 10 + t2;

            switch(t) {
                case 11: //都空闲
                return type1(x,y);
                case 12: //1号空闲 取二号位
                return type2(2,Task2);
                case 21: //取一号货，二号空闲
                return type2(1,Task1);
                case 13: //1号空闲 2号取货完成
                return type3(x,y,2,Task2);
                case 31: //1号取货完成，2号空闲
                return type3(x,y,1,Task1);
                //case 23: //1号取货中，2号取货完成
                //return type6(1);
                //case 32: //1号有货，2号取货
                //return type6(2);
                case 33: //取货都完成
                return type9(x,y,status);
                case 34: //1号有货2号放货
                return fanghuo(Task1,1,Task2);
                case 43: //1号放货。二号有货
                return fanghuo(Task2,2,Task1);
            }
            return null;
        }

       
        /**
         *
         * 任务不能立刻完成必须，需要预先执行的部分
         * 
         */
        TaskModel type1(int x,int y) {
            List<FullTask> res = getCanWorkingData();
            if(res.Count == 0) {
               // Logger.consol(CraneId + "号垛机未找到待执行任务");//会反馈号空闲
                return null;
            }
            TaskOrder order = TaskOrderUtil.pick2(x,y,res);
            List<TaskOrder> list = order.toList();
            TaskOrder select = TaskOrderUtil.firstUnworkTaskOrder(list);
            if(select == null) {
                return null;
            }
          
            ushort forkNo = (ushort)select.forkNo;
            List<int> bestOrder = new List<int>();
            bestOrder.Add(forkNo);
            bestOrder.Add(3-forkNo);
            forkNo = getPickForkNo(select.getTask(),list,bestOrder);
            
            if(forkNo == 0) {
                return null;
            }
            return packModel(rt,select.getTask(),forkNo);
        }

        TaskModel packModel(RTConfig rtushort,TaskCrane tc,ushort forkNo = 1) {
            if(tc.type == 1 && tc.MotionType == 1) {
                List<int> pointList = this.inPoint();
                foreach(int point in pointList) {
                    HySignalState s1 = CarrierPool.getSs(point);
                    if(s1 == null) {
                        continue;
                    }
                    if(s1.OnOff && s1.TaskNo == tc.TaskNo) {
                        PhysicalLocation pl= physicalLocationServer.getById(point);
                        tc.locDir = pl.Direction;
                        tc.locX = pl.X;
                        tc.locY = pl.Y;
                        tc.locId = pl.id;
                        craneTaskDAL.UpdateTaskById(tc.id,pl);
                        return CraneTools.ConvertTaskModel(rt,tc,forkNo);
                    }
                }
                return null;
            } 
            return CraneTools.ConvertTaskModel(rt,tc,forkNo);
        }



        public abstract ushort getPickForkNo(TaskCrane tc,List<TaskOrder> list,List<int> bastForkNo);

        public abstract int getPutPoint(int forkNo,TaskCrane tc,TaskCrane otherPutTc);

        TaskModel type2(ushort workingforkNo,TaskCrane tc) {
            List<FullTask> res = getCanWorkingData();
            
            if(res.Count == 1) {
                return null;
            } 
            FullTask ft1 = MathUtil.getFullTask(tc,res);

            int x = tc.locX;
            if(workingforkNo == 2) {
                x -= rt.CenterDistance1;
            }

            TaskOrder order = TaskOrderUtil.pick(x,tc.locY,ft1,res,workingforkNo);
            List<TaskOrder> orderlist = order.toList();
          

            if(orderlist[1].tc1.MotionType == 2) {//下一个任务是放货
                return null;
            }
            List<int> bestOrder = new List<int>();
            bestOrder.Add(3 - workingforkNo);
            ushort forkNo = getPickForkNo(orderlist[1].tc1,orderlist,bestOrder);
            if(forkNo == 0) {
                return null;
            }
            return packModel(rt,orderlist[1].tc1,forkNo) ;
           
        }
        //一个有货一个空闲，xy  当前位置
        /**
         * tc 将要执行的放货任务
         * */
        TaskModel type3(int x,int y,ushort hasStockForkNo,TaskCrane putTc) {
            List<FullTask> res = getCanWorkingData();
            TaskOrder order = null;
            FullTask ft1 = null;
            if(res.Count == 1) {
                ft1 = res[0];
                order = MathUtil.onlyOne(x,y,res);
            } else {
                 ft1 = MathUtil.getFullTask(putTc,res);
                order = TaskOrderUtil.pick(x,y,ft1,res,hasStockForkNo);
            }
            List<TaskOrder> craneList = order.toList();
            TaskOrder tc1 =  TaskOrderUtil.firstUnworkTaskOrder(craneList);
            TaskCrane tc = tc1.tc1;
            if( tc.MotionType == 1) {
                List<int> bestOrder = new List<int>();
                bestOrder.Add(3 - hasStockForkNo);
                ushort forkNo = getPickForkNo(tc,order.toList(),bestOrder);
                if(forkNo == 0) {
                   return packModel(rt,putTc,hasStockForkNo);
                }
                return packModel(rt,tc,forkNo);
            }else  if(tc.MotionType == 2&&tc.TaskNo == putTc.TaskNo) {//放货
                return fanghuo(tc,hasStockForkNo,null);
            } else {
                throw new Exception("不是放货，不是取下一个货物，任务异常");
            }
        }

        private TaskModel fanghuo(TaskCrane tc,ushort forkNo,TaskCrane otherPutTc) {

            if(tc.type == 2) {//出库
                int outPoint = getPutPoint(forkNo,tc,otherPutTc);
               
                if(outPoint == 0) {
                    return null;
                }
                PhysicalLocation pl = physicalLocationServer.getById(outPoint);
                craneTaskDAL.UpdateTaskById(tc.id, pl);
                tc = craneTaskDAL.GetItem(tc.TaskNo);
                return packModel(rt,tc,forkNo);
            } else {
                return packModel(rt,tc,forkNo);
            }

        }

        TaskModel type6(int workingForkNo) {
            List<FullTask> list = getCanWorkingData();
            TaskCrane tc1 = craneTaskDAL.getPickTask(CraneId,1);
            TaskCrane tc2 = craneTaskDAL.getPickTask(CraneId,2);
            FullTask ft1 = null;
            FullTask ft2 = null;
            foreach(FullTask ft in list) {
                if(ft.pick.TaskNo == tc1.TaskNo) {
                    ft1 = ft;
                }
                if(ft.pick.TaskNo == tc2.TaskNo) {
                    ft2 = ft;
                }
            }

            
            TaskCrane current = workingForkNo == 1 ? tc1 : tc2;
            int x = current.locX;
            if(workingForkNo == 2) {
                x -= TaskOrderUtil.CENTER_DISTANCE;
            }
           

            TaskOrder to = TaskOrderUtil.put2minTime(x,current.locY,ft1,ft2);
            List<TaskCrane> li = to.toCraneList();
            foreach(TaskCrane tc in li) {
                if(tc.MotionType == 2) {//第一个放货
                    if(tc.completeId != current.completeId) {
                        return fanghuo(tc,(ushort)(3- workingForkNo),null);
                    } else {
                        return null;
                    }
                }
            }
            return null;
        }

        TaskModel type9(int x,int y,RobotStatus status) {
            TaskCrane tc1 = craneTaskDAL.getPullTask(CraneId,1);
            TaskCrane tc2 = craneTaskDAL.getPullTask(CraneId,2);
            List<FullTask> res = getCanWorkingData();
            FullTask ft1 = null;
            FullTask ft2 = null;
            foreach(FullTask ft in res) {
                if(ft.put.TaskNo == tc1.TaskNo) {
                    ft1 = ft;
                }
                if(ft.put.TaskNo == tc2.TaskNo) {
                    ft2 = ft;
                }
            }
            TaskOrder to2 = TaskOrderUtil.put2minTime(x,y,ft1,ft2);
            List<TaskOrder> craneList = to2.toList();
            foreach(TaskOrder tc3 in craneList) {
                if(tc3.tc1.MotionType == 2) {
                    if(tc3.tc1.id == ft1.put.id) {
                        return fanghuo(ft1.put,1,ft2.put);
                    } else {
                        return fanghuo(ft2.put,2,ft1.put);
                    }
                }
            }
            return null;
        }
        public abstract List<int> inPoint();
       
    }
}
