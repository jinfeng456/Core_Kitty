using System;
using System.Threading;
using System.Threading.Tasks;
using GK.WCS.Common.dto;

namespace GK.WCS.Common
{
    public abstract class ZtTask
    {
      
        public TaskStat stat = new TaskStat();
        protected String className;
        private Task jobTask;
        protected int time = 600;
        protected bool exceptionSleep = true;
        private int extralSleep = 5000;
        private bool runed = false;
        private long beginTime;
        public ZtTask(){
            className = this.GetType().Name;
            stat.className = className;
        }

        public virtual bool init() {
            return true;
        }

        public void start(){
            try {
                lock(className) {
                    if(runed) {
                        LoggerCommon.consol(className + "已经启动");
                    }
                    if(!init()) {
                        LoggerCommon.consol(className + "初始化异常");
                        return;
                    }
                    runed = false;
                }

                jobTask = Task.Factory.StartNew(() => { doAction(); });
                LoggerCommon.fileAll(className + "成功");
            } catch (Exception e){
                LoggerCommon.error(className+"初始化异常，请查看日志记录",e);
            }
           
        }


        public virtual void onlyOneTime() {
       
        }

        public virtual long oneMaxTime()
        {
            return 2000 + time;
        }
        private void doAction() {
            Thread.Sleep(10000);
            do {
            
                try {
                    if (!runed) {
                        onlyOneTime();
                     
                        stat.time = this.time;
                        runed = true;
                    }
                    Thread.Sleep(time);
                    beginTime = DateTime.Now.Ticks;
                    excute();
                    stat.worklastTime = (DateTime.Now.Ticks-beginTime)/10000;
                    if (stat.worklastTime > oneMaxTime()) {
                        LoggerCommon.fileAll(className + "线程执行时间过长" + stat.worklastTime);
                    }
                    stat.workAllTime += stat.worklastTime;
                    stat.workCount++;
                    if(stat.worklastTime > stat.maxTime) {
                        stat.maxTime = stat.worklastTime;
                    }
                    if(stat.worklastTime < stat.minTime|| stat.minTime==0) {
                        stat.minTime = stat.worklastTime;
                    }
                    extralSleep = 5000;
                } catch (Exception ex) {
                    stat.exceptionCount++;
                    String show = string.Format("{0} sleep {1}s :{2}",className,extralSleep / 1000,ex.Message);

                    LoggerCommon.error(show,ex);

                    sleep();
                }
            } while (true);
         

        }

        private void sleep() {
         
            Thread.Sleep(extralSleep);
            extralSleep *= 2;
            if(extralSleep > 120000) {
                extralSleep = 120000;
            }
        }
        abstract  public void excute();

       
    }



}
