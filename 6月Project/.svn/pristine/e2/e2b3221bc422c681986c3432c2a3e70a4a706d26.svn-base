
using System.Collections.Generic;

using System;
using GK.WCS.Crane.dto;
using GK.WCS.Common;
using GK.WCS.Common.core.dto;
using GK.WCS.Carrier;
using GK.WCS.DAL;
using GK.WCS.Entity;
using GK.WCS.Common.task;
using GK.WCS.Carrier.dto;

namespace GK.WCS.Crane {
    public abstract class CraneDoubleForkTask:CraneAllocateJobHX {

        IPhysicalLocationServer physicalLocationServer = ServerFactray.getServer<IPhysicalLocationServer>();
        INoTaskControlServer noTaskControlServer = ServerFactray.getServer<INoTaskControlServer>();
        protected CarrierSynchro carrierSynchro = null;
        public CraneDoubleForkTask(int id) : base(id) {
        }
        protected override void onlyOneTime(){
            base.onlyOneTime();
            carrierSynchro = (CarrierSynchro)TaskPool.get<CarrierSynchro>();
        }



        sealed public override TaskCrane analyseTaskModel(GkCraneStatusBase gcs) {
            List<TaskCrane> tcList = craneTaskDAL.getWorkingTask(craneId);
            TaskCrane Task1 =getForkTask(tcList, 1);//1号货叉正在执行或者将要执行的任务
            TaskCrane Task2 = getForkTask(tcList, 2);//2hao 
            int t1 = null== Task1 ? 1:2;
            int t2 = null == Task2 ? 1 : 2;
           
            int x = gcs.getX();
            int y = gcs.getY();
            //1,空闲，2取货中

            int t = t1 * 10 + t2;

            switch (t) {
                case 11: //都空闲
                    return type1(x, y);
                case 12: //1号空闲 取二号位
                    return type2(2, Task2);
                case 21: //取一号货，二号空闲
                    return type2(1, Task1);
                
            }
            return null;
        }

        public  TaskCrane getForkTask(List<TaskCrane> tcList, int forkNo) {
            TaskCrane Task1 = null;
            foreach (TaskCrane tc in tcList) {
                if (tc.forkNo == forkNo) {
                    if (Task1 != null) {
                        throw new Exception(tc.taskNo + "数据库任务重复" + Task1.taskNo);
                    }
                    Task1 = tc;
                }
            }
            return Task1;
        }

        /**
         *
         * 任务不能立刻完成必须，需要预先执行的部分
         * 
         */
        TaskCrane type1(int x,int y) {
            List<TaskCrane> res  = craneTaskDAL.getWorkingTask(craneId);
            if (res.Count == 0) {
               // Logger.consol(CraneId + "号垛机未找到待执行任务");//会反馈号空闲
                return null;
            }
            TaskOrder order = TaskOrderUtil.pick2(x,y,res);
            List<TaskOrder> list = order.toList();
            TaskOrder select = TaskOrderUtil.firstUnworkTaskOrder(list);
            if(select == null) {
                return null;
            }
          
            ushort forkNo = (ushort)select.forkNo;
            List<int> bestOrder = new List<int>();
            bestOrder.Add(forkNo);
            bestOrder.Add(3-forkNo);
            forkNo = getPickForkNo(select.getTask(),list,bestOrder);
            
            if(forkNo == 0) {
                return null;
            }
            return packModel(select.getTask(),forkNo);
        }

        TaskCrane packModel(TaskCrane tc,ushort forkNo = 1) {
            if(tc.taskType == 1 ) {
                List<int> pointList = this.inPoint();
                foreach(int point in pointList) {

                    CarrierSignalStatus s1 = carrierSynchro.getSignalStatut(point);
                    if(s1 == null) {
                        continue;
                    }
                  
                }
                return null;
            } 
            return tc;
        }



        public abstract ushort getPickForkNo(TaskCrane tc,List<TaskOrder> list,List<int> bastForkNo);

        public abstract int getPutPoint(int forkNo,TaskCrane tc,TaskCrane otherPutTc);

        TaskCrane type2(ushort workingforkNo,TaskCrane tc) {
            List<TaskCrane> res = craneTaskDAL.getWorkingTask(craneId);

            if (res.Count == 1) {
                return null;
            }
            TaskCrane ft1 = MathUtil.getFullTask(tc,res);

           
            List<int> bestOrder = new List<int>();
            bestOrder.Add(3 - workingforkNo);
        
            return null ;
           
        }
        
        public abstract List<int> inPoint();
       
    }
}
