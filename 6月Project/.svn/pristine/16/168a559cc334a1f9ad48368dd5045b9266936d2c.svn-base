
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using CMNetLib.ModBus;
using CMNetLib.Robots.Crane;
using GK.WCS.Common;
using GK.WCS.Common.task;
using GK.WCS.Crane;

namespace GK.WCS.Crane {
    //输送线
    public abstract class CraneReader:ZtTask {
        protected int craneId;
        CraneConnect craneConnect = null;
       
        public short DI_Num = 16;

        public short DO_Num = 16;
        public short AI_Num = 1;

        public short AO_Num = 1;
      

        public const ushort TASK_SINGLE_LEN = 14;
        private RobotStatus robotState;
        public CraneReader(int craneId) {
            this.craneId = craneId;
         
        }
        abstract public void craneExcute(RobotStatus status);

        public override void onlyOneTime() {
            craneConnect = (CraneConnect)TaskPool.get<CraneConnect>(craneId);
            time = 400;
        }
        public override void excute() {
                ushort len = (ushort)(craneConnect.ForkNos * 4 + 11 + (int)(this.DI_Num / 16) + (int)(this.DO_Num / 16) + (int)this.AI_Num + (int)this.AO_Num);
            ushort start = (ushort)((int)CraneReader.TASK_SINGLE_LEN * craneConnect.ForkNos + 1);
            long t = DateTime.Now.Ticks;
            byte[] array = craneConnect.getData(start,len);
            
            this.robotState = new RobotStatus();

            this.robotState.RoundtripTime = (DateTime.Now.Ticks - t)/10000;
                this.ParseTelex(array);
                craneExcute(this.robotState);


        }

        byte[]  getRobotStatus(byte[] b) {
            this.robotState.IsSystemManual = (b[0] == 1);
            this.robotState.Mode = (RobotMode)b[0];
            this.robotState.SystemManualAcCode = (ManualActionCode)b[1];
            this.robotState.SystemManualSpeed = Tools.ushort16(b,2);
            this.robotState.SystemManualAcDelay = Tools.ushort16(b,4);
            return b.Skip(6).ToArray<byte>();
            
        }

       
        byte[] getForkStatu(byte[] b) {
            for(int i = 0;i < craneConnect.ForkNos;i++) {
                bool flag = Enum.IsDefined(typeof(ForkErrCode),b[ i * 8]);
                if(flag) {
                    this.robotState.ForkStatus.Add(i + 1,(ForkErrCode)b[ i * 8]);
                } else {
                    this.robotState.ForkStatus.Add(i + 1,ForkErrCode.UNKNOWN_ERROR);
                }
                this.robotState.TaskState.Add(new TaskStatusModel {
                    ForkNo = (ushort)(i+1),
                    State = (CMNetLib.Robots.Crane.TaskStatus)(Enum.IsDefined(typeof(CMNetLib.Robots.Crane.TaskStatus),b[ i * 8 + 1]) ? b[ i * 8 + 1] : 255),
                    IsIn = b[ i * 8 + 3],
                    TaskNo = Tools.int32(b,i * 8 + 4) 
                });
              
            }

            return b.Skip(craneConnect.ForkNos*8).ToArray<byte>();
        }

        byte[] getspeed(byte[] b) {
            int num = 0;
            try {
                this.robotState.errCode = (CraneErrCode)b[num];
            } catch(Exception) {
                this.robotState.errCode = CraneErrCode.UNKNOWN_ERROR;
            }
            this.robotState.errCodeNo = b[num];
            this.robotState.errDatailCode = b[num + 1];
            this.robotState.X_Speed = Tools.short16(b,num + 2);
            this.robotState.Y_Speed = Tools.short16(b,num + 4);
            this.robotState.NowX = Tools.int32(b,num + 6);
            this.robotState.NowY = Tools.int32(b,num + 10);
            this.robotState.Cranestatus = (CraneStatus)b[num + 15];
            return b.Skip(num + 16).ToArray<byte>();
        }

        private void ParseTelex(byte[] b) {
        
                b = getRobotStatus(b);
                b = getForkStatu(b);
                b = getspeed(b);
                this.ParseIO(b);
           
        }

        private void ParseIO(byte[] b) {
            bool flag = this.DI_Num % 16 != 0;
            if(!flag) {
                for(int i = 0;i < (int)(this.DI_Num / 16);i++) {
                    BitArray bitArray = new BitArray(new byte[]
                    {
                        b[1 + i * 2],
                        b[i * 2]
                    });
                    this.robotState.DI = new List<DIO>();
                    short num = 1;
                    while((int)num < bitArray.Length + 1) {
                        this.robotState.DI.Add(new DIO {
                            Address = num,
                            OnOff = bitArray[bitArray.Length - (int)num]
                        });
                        num += 1;
                    }
                }
                int num2 = (int)(this.DI_Num * 2 / 16);
                this.robotState.AI = new List<AIO>();
                for(short num3 = 1;num3 < this.AI_Num + 1;num3 += 1) {
                    this.robotState.AI.Add(new AIO {
                        Address = num3,
                        A = Tools.short16(b,num2 + (int)((num3 - 1) * 2))
                    });
                }
                num2 += (int)(this.AI_Num * 2);
                bool flag2 = this.DO_Num % 16 != 0;
                if(!flag2) {
                    for(int j = 0;j < (int)(this.DO_Num / 16);j++) {
                        BitArray bitArray2 = new BitArray(new byte[]
                        {
                            b[num2 + 1 + j * 2],
                            b[num2 + j * 2]
                        });
                        this.robotState.DO = new List<DIO>();
                        short num4 = 1;
                        while((int)num4 < bitArray2.Length + 1) {
                            this.robotState.DO.Add(new DIO {
                                Address = num4,
                                OnOff = bitArray2[bitArray2.Length - (int)num4]
                            });
                            num4 += 1;
                        }
                    }
                    num2 += (int)(this.DO_Num * 2 / 16);
                    this.robotState.AO = new List<AIO>();
                    for(short num5 = 1;num5 < this.AO_Num + 1;num5 += 1) {
                        this.robotState.AO.Add(new AIO {
                            Address = num5,
                            A = Tools.short16(b,num2 + (int)((num5 - 1) * 2))
                        });
                    }
                }
            }
        }

    }
}
