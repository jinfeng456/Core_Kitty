using System;
using System.Collections.Generic;
using System.Linq;
using GK.WCS.Entity;
using GK.WCS.Crane.dto;

namespace GK.WCS.Crane {
    
    public class MathUtil {
        public static TaskCrane getFullTask(TaskCrane tc,List<TaskCrane> res) {
            for(int i = 0;i < res.Count;i++) {
                TaskCrane ft = res[i];
                if(ft.id == tc.id|| ft.id == tc.id) {
                   return ft;
                }
            }
            return null;
        }
        

        public static int dis(TaskCrane tc,int X, int Y) {
            return Math.Abs(tc.fromPlcCol - X) + Math.Abs(tc.fromPlcRow - Y);
           
        }

        public static bool at(int X,int Y,int x,int y) {

            int defX = x - X;
            int defY = y - Y;
            if(Math.Abs(defX) < 1000 && Math.Abs(defY) < 1000) {
                return true;
            }
            return false;
        }

        public static TaskOrder onlyOne(int x,int y,List<TaskCrane> fullTaskList) {
            TaskCrane ft = fullTaskList[0];
            TaskOrder order = new TaskOrder(MathUtil.dis(ft,x,y),ft,ft,0);
            TaskOrder order2 = new TaskOrder(0,ft,ft,0);
            order.add(order2);
            return order;
        }

        public static TaskOrder pick2(int x,int y,List<TaskCrane> fullTaskList) {
            int count = fullTaskList.Count;
            if(fullTaskList.Count == 1) {
                return onlyOne( x,y,fullTaskList);
            } 
           TaskOrder minOrder = null;
            for(int i = 0;i < count;i++) {
                TaskCrane ft1 = fullTaskList[i];
                TaskOrder order = fromTask(x,y,ft1,fullTaskList);
                minOrder = min(minOrder,order);
            }

            return minOrder;
        }

       public static TaskOrder fromTask(int x,int y, TaskCrane ft1,List<TaskCrane> fullTaskList) {
            TaskOrder order = new TaskOrder(MathUtil.dis( ft1,x,y),ft1,ft1,0);
        

            TaskOrder order1 = pickFirst(ft1,fullTaskList);
            order.add(order1);
            return order;

        }


        public static TaskOrder pick(int x,int y,List<TaskCrane> fullTaskList) {
            int count = fullTaskList.Count;
            TaskOrder minOrder = null;
            for(int i = 0;i < count;i++) {
                TaskCrane ft = fullTaskList[i];
                TaskOrder order2 = new TaskOrder(MathUtil.dis( ft,x,y),ft,ft,0);
                TaskOrder order3 = null ;
                order2.add(order3);
                minOrder = min(minOrder,order2);
            }

            return minOrder;
        }


        static TaskOrder pickFirst(TaskCrane ft1,List<TaskCrane> fullTaskList) {

            int x = 0;
            int y = 0;

            int count = fullTaskList.Count;
            if(fullTaskList.Count == 1) {
                return onlyOne(x,y,fullTaskList);
            }
            TaskOrder minOrder = null;

            foreach(TaskCrane ft in fullTaskList) {
                if(ft.id == ft1.id) {//同一个对象
                    continue;
                }
                TaskOrder pickRorder = pickTegether(ft1,ft);
                minOrder = min(minOrder,pickRorder);
                pickRorder = oneByOne(ft1,ft);
                minOrder = min(minOrder,pickRorder);
            }
            return minOrder;
        }
        /**
         *  //取ft1的情况下，
         * */

        private static TaskOrder pickTegether(TaskCrane ft1, TaskCrane ft) {//取两个货的时间
         
            return null;
        }
        private static TaskOrder oneByOne(TaskCrane ft1, TaskCrane ft) {
           
            return null;
        }

        public static TaskOrder put2minTime(int x,int y, TaskCrane ft1, TaskCrane ft2) {//放两个货的时间

           
             
            return null;
        }

        public static TaskOrder min(TaskOrder minOrder,TaskOrder order1) {
            if(minOrder == null) {
                return order1;
            }
            if(minOrder.time > order1.time) {
                return order1;
            }
            return minOrder;
        }

    }
}
